---
title: "[C] 10. 포인터"
excerpt: "포인터(Pointer)"
categories:
  - C
tags:
  - pointer
---
{{ page.excerpt }}
* * *

## 메모리 주소

```c
#include <stdio.h>
int main() {
  int num1 = 10;

  // 008AF7FC: num1의 메모리 주소를 출력
  // 컴퓨터마다, 실행할 때마다 달라짐
  printf("%p\n", &num1);

  return 0;
```

- 실행 결과: 0061FE1C (메모리 주소. 컴퓨터마다, 실행할 때마다 달라짐)
- 메모리 주소는 008AF7FC과 같이 16진수 형태이며 printf에서 서식지정자 %p(pointer의 약어로 p를 사용)를 사용하여 출력할 수 있다
- 변수의 메모리 주소를 구할 때는 변수 앞에 &(주소 연산자)를 붙여서 나타냄
- 시스템이 32비트인지 64비트인지에 따라 메모리 주소의 범위 변경됨
- 32비트: 16진수 8자리
  - 0x00000000 ~ 0xFFFFFFFF
  - 예) 0x008AF7FC
- 64비트: 16진수 16자리
  - 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF
  - 예) 0x00000000008AF7FC
  - 64비트 메모리 주소는 0x00000000\`00000000처럼 8자리 씩 끊어서 \`를 붙이는 경우도 있음
- 리눅스, OS X에서 메모리 주소
  - 리눅스, OS X에서 서식 지정자 %p를 사용하면 메모리 주소 008AF7FC는 0x8af7fc와 같이 앞에 0x가 붙고, A~F는 소문자로 출력

## 포인터를 사용하는 이유
- 효율적인 대형 자료 구조 관리
  - 배열 or 구조체
- 함수 사이의 데이터 공유
  - 포인터를 파라미터로 사용
- 동적 메모리 할당 지원
  - 프로그램이 실행되는 동안에 메모리 할당이 가능함
- Linked list 지원
  - Linked list는 데이터가 담긴 노드(메모리 공간)를 일렬로 연결되어 있는 자료구조
  - 노드 사이를 포인터를 이용하여 연결 할 수 있음

## 포인터 변수 선언
- 포인터 변수 선언 방법

```c
// int 는 자료형
// *numPtr 은 포인터의 이름
int *numPtr;
```

- 포인터 변수 사용법

```c
// 포인터 변수명: 메모리 주소를 저장
// (&주소 연산) &로 변수의 주소를 가져옴
numPtr = &num1;
```

```c
#include <stdio.h>
int main() {
  int *numPtr;          // 포인터 변수 선언
  int num1 = 10;      // int형 변수를 선언하고 10 저장

  numPtr = &num1;  // num1의 메모리 주소를 포인터 변수에 저장

  return 0;
}
```

- 포인터 연산자
  - 주소 연산자(Address Operator): `&`
    - 변수의 주소를 되돌려주는 역할
  - 역참조 연산자(Indirection Operator): `*` (Asterisk, 애스터리스크) (간접 접근 연산자)
    - 해당 주소에 있는 변수의 값을 되돌려 주는 역할

```c
// 선언 pointer variable 'p'
int *p;

int i = 3;

// i 변수의 주소를 p에 할당
// p 포인터 변수는 i를 가리킴
p = &i;

// 역참조(*) 연산에 의하여 포인터 변수 p가 가지고 있는 주소에 있는 변수 a의 값 3을 되돌려 받음
printf("%d", *p);
```

```c
// int *p, q, r; 와 같은 의미를 가짐
// p: 포인터 변수 q, r: 정수형 변수
int* p, q, r;

// p, q, r: 포인터 변수
int *p, *q, *r;
```

## 다중 포인터
- 하나의 변수에 여러 포인터 변수를 연결하여 사용할 수 있음

```c
// 포인터 변수 q와 p 모두 a를 가리키고 있다(a의 메모리 주소를 가지고 있다)
int a = -123;
int* p = &a;
int* q;
q = p;
```

## 포인터 연산자의 활용

```c
int x, *p
x = 10;
p = &x;
```

```c
int x, *p = &x;
*p = 10;
```

위 아래 둘 다 같은 의미

```c
printf("%d", *p);
```

```c
printf("%d", x);
printf("%d", *&x);
```

위 아래 둘 다 같은 의미 ( x == *&x )

```c
// 여러 포인터 변수와 하나의 정수 변수
int a = 10;
int *p, *q, *r;
p = q = r = &a;
```

## 포인터 연산의 오류 예시

```c
// 포인터 변수 p는 초기화 되지 않아서 값을 저장할 수 없음
int x, *p;
x = 10;
*p = x;
```

```c
// 포인터 변수에는 일반 정수형 변수가 가지는 값을 저장할 수 없음
int x, *p;
x = 10;
p = x;
```

## 배열과 포인터
- `배열의 이름`은 포인터 변수와 같은 역할
- 배열의 이름 = 배열의 첫 번째 원소의 주소

```c
double list[3], *p;

p = &list[0]; // p = list; 와 같다
```

- 포인터 변수에 배열을 지정

```c
#include <stdio.h>
int main() {
  int a[5] = { 2, 4, 6, 8, 22 };
  int *p = a;

  // *p is same as p[0]
  printf("%d %d\n", a[0], *p);

  return 0;
}
```

- 포인터 변수에 배열의 두 번째 항목 연결

```c
#include <stdio.h>

int main() {
  int a[5] = { 2, 4, 6, 8, 22 };
  int *p;

  p = &a[1];
  printf("%d %d", a[0], p[-1]);
  printf("\n");
  printf("%d %d", a[1], p[0]);

  return 0;
}
```

## 포인터의 연산
- 포인터 변수의 더하기

```c
int a[10], *p, *q;

p = a; // p = &a[0]; 와 같음
q = a + 3; // q = &a[3]; 와 같음

*p = 5; // a[0] = 5; 와 같음
*q = 9; // a[3] = 9; 와 같음
```

- 포인터에 더하기와 빼기의 경우 선언한 데이터 형식의 크기만큼 이동

```c
a + n * (sizeof(one element))
```

- 포인터 변수의 빼기

```c
p = &a[5];
q = &a[1];

i = p - q; // i = 4
i = q - p; // i = -4
```

- 포인터 변수의 비교
  - 관계 연산자: <, <=, >, >=
  - 비교 연산자: ==, !=

```c
p = &a[5];
q = &a[1];

if (p <= q) printf("pointer p has a small value"); // result is 0

if (p >= q) printf("pointer p has a large value"); // result is 1

if (p == q) printf("equal value"); // result is 0
```

```c
int a[] = { 5, 15, 25, 43, 12, 1, 7, 89, 32, 11 };
int *p = &a[1], *q = &a[5];

1. *(p + 3) // 12
2. *(q - 2) // 43
3. q - p // 4
4. if (p > q) // false
5. if (*p > *q) // true
```

## 배열의 포인터 연산

| 배열 표현법 | 포인터 표현법 |
| --- | --- |
| a[0], p[0] | *a, *p |
| a[1], p[1] | *(a+1), *(p+1) |
| a[2], p[2] | *(a+2), *(p+2) |
| a[3], p[3] | *(a+3), *(p+3) |

- 배열명을 이용한 데이터 접근과 포인터 배열을 이용한 데이터 접근 비교

```c
#define N 10
int a[N], sum, *p, i;

sum = 0;
for (p = a; p < &a[N]; ++p) {
  sum += *p;
}

// Corresponding to
// for (i = 0; i < N; i++) sum += *(p+i);
// for (i = 0; i < N; i++) sum += p[i];

// for (i = 0; i < N; ++i) sum += *(a + i);
// for (i = 0; i < N; ++i) sum += a[i];
```

## 역참조 연산자(*)와 증가연산자(++)

| 표현식 | 의미 |
| --- | --- |
| *p++ or *(p++) | *p의 값에 접근 후, p가 가지고 있는 주소 증가 |
| (*p)++ | *p의 값에 접근 후에, 해당하는 값이 증가 |
| *++p or *(++p) | 포인터 변수 p가 가지고 있는 주소가 증가한 후, 값에 접근 |
| ++*p or ++(*p) | 포인터 변수 p가 값에 접근 후, 해당하는 값이 증가 |

```c
int a[3] = { 20, 7, -9 }, *p, i;
p = &a[1];

i = *p++; // i = 7, *p = -9
i = *++p; // i = -9, *p = -9
i = ++*p; // i = 8, *p = 8
i = (*p)++; // i = 7, *p = 8
```

```c
// 0으로 배열 초기화 예시1
int a[10], *p = &a[0], i;

for( i = 0; i < 10; i++ ) {
  a[i] = 0;
}
```

```c
// 0으로 배열 초기화 예시2
int a[10], *p = &a[0], i;

for( ; p<= &a[9]; p++ ) {
  *p = 0;
}

for( p = a; p <= &a[9]; p++ ) {
  printf("%d ", *p);
}
```

```c
// 0으로 배열 초기화 예시3
int a[10], *p = &a[0], i;

for( ; p <= &a[9] ; ) {
  *p++ = 0;
}

for( p = a; p <= &a[9] ; ) {
  printf("%d ", *p++);
}
```

## 2차원 배열과 포인터
- 2차원 배열은 메모리에서는 순차적으로 나열되어 나타남

```c
int a[3][5];
int *p = &a[0][0];
```

```c
int a[M][N], *p;

// 0로 2차원 배열 초기화 예시
for( p = &a[0][0]; p <= &a[M-1][N-1]; p++) {
  *p = 0;
}
```

- 2차원 배열에서 행의 증가를 포인터 연산으로 처리
  - *(table + 1)
  - table[1] 와 같다 (= 두 번째 행)

```c
int table[3][4];

for( i = 0; i < 3; i++) {
  for( j = 0; j < 4; j++) {
    printf("%6d", *( *(table + i) + j));
  }
  printf("\n");
}
```

- 2차원 배열의 초기화

```c
int a[2][3], *p = &a[0][0], i, j;

for( i = 0; i < 2; i++) {
  // 3은 열의 크기
  for( p = a[i]; p < a[i] + 3; p++) {
    *p = 0;
  }
}
```

```c
for( p = &a[0][0]; p <= &a[1][2]; p++) {
  *p = 0;
}
```

## 2차원 배열과 함수
- 함수에서 2차원 배열을 포인터 함수로 넘겨줄 경우
  - 2차원 배열의 열의 값은 반드시 고정된 상수로 지정하여야 함
  - 행의 경우는 없어도 무방

```c
int sum( int m[][4] ); // int sum( int (*m)[4] );
```
